---
title: Pentesting Tools
description: Details about Pentesting Tools in Athena OS.
---
import ThemedImage from '@components/ThemedImage.astro';

Athena hacking tool surface mainly leverages on BlackArch repository.

[BlackArch Linux](https://blackarch.org/) is an Arch-based Linux pentesting distribution for penetration testers and security researchers. Its repository contains [2800+ tools](https://blackarch.org/tools.html), classified for categories. You can install tools individually or in groups according to the categories they belong. BlackArch Repository is compatible with only Arch-based distributions as Athena OS.

Hacking tools can be installed and used in several ways by:
* Single tools
* Cyber Security roles
* Red Team menu
* Categories

### Single tools

For installing a single tool, you can simply run `sudo pacman -S <tool-name>`.

### Cyber Security roles

Cyber Security roles allow to install hacking tools according to a specific role. Each one of these roles is linked to a package that is installed according to the following table:

| Role | Package |
| ---- | ------- |
| üíô Blue Teamer üíô | athena-blueteamer |
| üêû Bug Bounty Hunter üêû | athena-bountyhunter |
| üçò Cracker Specialist üçò | athena-cracker |
| üíÄ DoS Tester üíÄ | athena-dos |
| üéì Enthusiast Student üéì | athena-student |
| üîç Forensic Analyst üîç | athena-forensic |
| ü¶† Malware Analyst ü¶† | athena-malware |
| üì± Mobile Analyst üì± | athena-mobile |
| üåê Network Analyst üåê | athena-network |
| üïµÔ∏è OSINT Specialist üïµÔ∏è | athena-osint |
| ‚ù§Ô∏è Red Teamer ‚ù§Ô∏è | athena-redteamer |
| üï∏Ô∏è Web Pentester üï∏Ô∏è | athena-webpentester |

These packages are created as metapackages and they are checked carefully in order to prevent any conflicts among dependencies.

Since the packages inside each role could evolve frequently, reporting all tools on a document could not be efficient. If you wish to know what are the tools for each role, you can use two methods:
1. opening **Athena Welcome** and click on **Show Tools for Roles** button
   * you can filter the roles by the button on the bottom side
     ![Athena Welcome Role Tools](@assets/athena-welcome-roletools.png)
2. running `pacman -Sii <role-package> | grep -Po '^Depends On\s*: \K.+' | head -1`
   * where `<role-package>` should be replaced by the package of a role, for example `athena-redteamer`.

You can set your Cyber Security role as described [here](/en/resources/athena-welcome/#cyber-security-roles).

You can set more than one role, Athena Welcome will keep the latest set role.

### Red Team menu

Athena OS GNOME uses Red Team menu for accessing to the main hacking tools. It is better described in detail [here](/en/resources/redteam-menu/).

### Categories

There are several categories deployed as package group that users can install by `sudo pacman -S <category>`:

| Category | Description |
| -------- | ----------- |
| blackarch-anti-forensic | Countering forensic activities. |
| blackarch-automation | Workflow automation. |
| blackarch-automobile | Analyzing automotive applications. |
| blackarch-backdoor | Exploiting or open backdoors on already vulnerable systems. |
| blackarch-binary | Operating on binary in some form. |
| blackarch-bluetooth | Using Bluetooth attacks. |
| blackarch-code-audit | Auditing existing source code for vulnerability analysis. |
| blackarch-cracker | Cracking cryptographic functions. |
| blackarch-crypto | Working with cryptography, with the exception of cracking. |
| blackarch-database | Database exploitations on any level. |
| blackarch-debugger | Debugging resources in realtime. |
| blackarch-decompiler | Reversing a compiled program into source code. |
| blackarch-defensive | Protecting resources from malware and attacks. |
| blackarch-disassembler | Producing assembly output rather than the raw source code. |
| blackarch-dos | Using DoS (Denial of Service) attacks. |
| blackarch-drone | Managing physically engineered drones. |
| blackarch-exploitation | Taking advantages of exploits in other programs or services. |
| blackarch-fingerprint	| Exploiting fingerprint biometric equipment. |
| blackarch-firmware | Exploiting vulnerabilities in firmware. |
| blackarch-forensic | Finding information on physical disks or embedded memory. |
| blackarch-fuzzer | Fuzzing tools. |
| blackarch-hardware | Exploiting or managing anything to do with physical hardware. |
| blackarch-honeypot | Acting as "honeypots", i.e., programs that appear to be vulnerable services used to attract hackers into a trap. |
| blackarch-ids	| Intrusion Detection System tools. |
| blackarch-keylogger | Recording and retaining keystrokes on a target system. |
| blackarch-malware	| Malicious software or malware detection. |
| blackarch-misc | Miscellaneous tools. |
| blackarch-mobile | Manipulating mobile platforms. |
| blackarch-networking | Scanning selected systems for vulnerabilities or information about the network. |
| blackarch-nfc	| NFC technology tools. |
| blackarch-packer | Operating on or involve packers. |
| blackarch-proxy | Acting as a proxy, i.e., redirecting traffic through another node on the internet. |
| blackarch-radio | Operating on radio frequency. |
| blackarch-recon | Actively seeking vulnerable exploits in the wild. |
| blackarch-reversing | Any decompiler, disassembler or any similar program. |
| blackarch-scanner	| Scanning selected systems for vulnerabilities or information about the network. |
| blackarch-sniffer	| Analyzing network traffic. |
| blackarch-social | Social engineering attacks. |
| blackarch-spoof | Spoofing attacker entity. |
| blackarch-stego | Analyzing resources for hidden information. |
| blackarch-tunnel | Tunneling network traffic on a given network. |
| blackarch-voip | Operating on VoIP programs and protocols. |
| blackarch-webapp | Web application attacks tools. |
| blackarch-windows	| Native Windows packages. |
| blackarch-wireless | Operating on wireless networks on any level. |

## Submitting Tools

If you wish to submit a new pentesting tool that is not in any Arch Linux or BlackArch repository, this section will help you.

Pentesting tools are mainly maintained in BlackArch repository, so your new pentesting tools must be stored there.

1. Create a **PKGBUILD** file containing the rules for compiling and installing `mytoolname`. According to the type of the tool, you must start from one of [these PKGBUILD templates](https://github.com/BlackArch/blackarch-pkgbuilds)
   * i.e., if it is a bash tool that comes from GitHub or GitLab, you can refer to [PKGBUILD-generic-git]
   * copy the content of the PKGBUILD template file inside a new file named `PKGBUILD` created in `blackarch/packages/<mytoolname>` folder.
2. Fill the variable inside PKGBUILD according to the tool information. If you are new on PKGBUILD, give a look to the [official Arch Linux documentation](https://wiki.archlinux.org/title/PKGBUILD). You can check several examples in [BlackArch repository](https://github.com/BlackArch/blackarch/tree/master/packages/)
   * when you write information inside PKGBUILD, there are several best practices you must follow:
      * Insert [disclaimer comments](https://github.com/BlackArch/blackarch-pkgbuilds/blob/66259a614509ab1f78075bc897d3cb10d832ed13/PKGBUILD-generic#L1-L2)
      * Never put upper case in `pkgname=`
      * AUR packages are written bad. Change them in order to be BlackArch convention compliant
      * In `groups=`, insert the right BlackArch categories
      * Insert empty line before `pkgver()`
      * Add a blank line after `cd $pkgname` inside `pkgver()`
      * When something gets compiled (C, go, rust, etc.), use `arch=('x86_64' 'aarch64')` rather than `arch=('any')`.
      * On SHA sums, SKIP is only for git
      * If the project use tags `https://github.com/<owner>/<repo-name>/tags`, inside of `pkgver()` use `git describe --long --tags | sed 's/\([^-]*-g\)/r\1/;s/-/./g'` instead of `echo $(git rev-list --count HEAD).$(git rev-parse --short HEAD)`
      * Remove [useless dependencies](https://github.com/BlackArch/blackarch/pull/3883)
      * Don't use a virtual environment (like `python -m venv venv` command), we use those only for very complex cases
      * Usually don't add `pip install -r requirements.txt` command. It should be used only for Python virtualenv installs that we absolutely try to avoid. Instead, we need to insert those dependencies in `depends=` as packages
      * Add `cd $pkgname` as first line in `package()`
      * Use `$variable` and not `${variable}`
      * For Python Setup template, in URL insert the GitHub project URL if it exists, but, by source variable, retrieve the package from pypi website
      * Use `install -dm 755 "<directory>"` instead of `mkdir -p` (`-d` is used for creating directories), for example `install -dm 755 "$pkgdir/usr/bin"`
      * If needed, for avoiding the repetition of a path to different files, use `cd <path-to-files>`
      * Remove all template comments
      * Add always a new line at the end of the PKGBUILD. If you are editing the PKGBUILD by GitHub WebUI, you need to have at the end two newlines
      * Don't just copy/paste from AUR that are often low quality PKGBUILD, it needs to be adapted to BA standards.
      * Try to do all edits related to one package in the same Pull Request: You know when you edit a file with github webui to prepare your PR (Pull Request) it basically just create a branch patch-X on your fork (i.e., [here](https://github.com/D3vil0p3r/blackarch/tree/patch-8)) based on `BlackArch:master`. So for example here, you can browse `D3vil0p3r:patch-8` and create `python-instagram-private-api` PKGBUILD there so it will be added to the same PR rather than creating a new PR for it. One PR per tool is nice but when it's the dependencies of the tool it's best to have them in the same PR
      * Add `mytoolname` to lists/to-release file in BlackArch repository
      * Create a Pull Request with title `<package-name>: add package`
      * For Python packages
        * even if the convention is `python-<pythonpkgname>`, respect that even if that makes `python-python-something`
        * if you have both `setup.py` and `pyproject.toml` in Python source files, use always the [PKGBUILD-python-lib-PEP517](https://github.com/BlackArch/blackarch-pkgbuilds/blob/master/PKGBUILD-python-lib-PEP517) template
3. If your tool does not come from git source, you can compute the `sha512sum` easily by running `updpkgsums` in the same folder of PKGBUILD.
4. Test if the PKGBUILD compiles and installs the tool correctly
   * You can test your PKGBUILD in a clean sandbox by **ba-dev** as described [here](https://gist.github.com/noraj/5045be32490f1161161e16fc5820066c#testing), for example:
     ```
     $ sudo pacman -S blackarch-devtools
     $ ba-dev -b
     $ ba-dev -e 'python' -p python-instagram-private-api-1.6.0.0-1-any.pkg.tar.zst
     Package python-instagram-private-api-1.6.0.0-1-any.pkg.tar.zst installed correctly! Testing it now...
     Python 3.10.9 (main, Dec 19 2022, 17:35:49) [GCC 12.2.0] on linux
     Type "help", "copyright", "credits" or "license" for more information.
     >>> from instagram_private_api import Client, ClientCompatPatch
     ```
     Another example [here](https://github.com/BlackArch/blackarch/issues/3661#issuecomment-1371499848)
5. If the test works, you can also try to install the tool by this PKGBUILD directly on your system by `makepkg -si` command.
6. If all is working well, go on [BlackArch repository packages](https://github.com/BlackArch/blackarch/tree/master/packages/), click on **Add file** -> **Create new file**. It will ask to create a fork. Then, as filename, insert `mytoolname/PKGBUILD`. It will create the folder `mytoolname` and inside it an empty `PKGBUILD` folder. Inside this `PKGBUILD` paste the content of the working PKGBUILD tested above and commit the changes. These changes are applied on your fork. Create a **Draft Pull Request** when requested and name it as `<package-name>: added package`.
7. Then go to your forked repository and edit the file `blackarch/lists/to-release` by adding there the name of the tool, for example `mytoolname`. When you apply also these changes, your draft pull request will automatically have also this last change.
8. Go to your draft pull request and submit it. You need to wait for BlackArch maintainers that will check your submission and merge your pull request.

*Note: for Python packages it is preferred to retrieve the file from PyPI instead of GitHub repositories because of integrity check, check for dependency changes at each release, and a [script](https://github.com/BlackArch/blackarch/blob/master/scripts/up-libraries) to auto-bump on new release for PyPI releases*

:::caution
If your submitted tool has some dependencies that are not in BlackArch or Arch Linux repositories, you need to create a PKGBUILD dedicated to it in BlackArch repository itself. For example, in your forked repository you should create the PKGBUILD file in another directory as `blackarch/packages/yourdependency/PKGBUILD`. The PKGBUILD related to a depedency of a tool does not need of the field `groups=('blackarch' MORE_BLACKARCH_GROUPS_HERE).`
:::